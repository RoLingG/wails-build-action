name: "Discovery"
description: "Detect OS/ARCH and (on Linux) distro; install required packages; expose repo/ref metadata; detect project markers (root and subtree)"
inputs:
  working-directory:
    description: "Directory to scan for project markers (root of the app)"
    required: false
    default: "."
runs:
  using: "composite"
  steps:
    - name: Linux discovery and deps
      if: runner.os == 'Linux'
      id: linux
      shell: bash
      run: |
        set -euo pipefail
        sudo apt-get -yq update
        DISTRO=$(lsb_release -rs)
        if [[ "$DISTRO" == "20.04" ]]; then
          sudo apt-get -yq install libgtk-3-0 libwebkit2gtk-4.0-dev gcc-aarch64-linux-gnu
        elif [[ "$DISTRO" == "22.04" ]]; then
          sudo apt-get -yq install libgtk-3-0 libwebkit2gtk-4.0-dev gcc-aarch64-linux-gnu
        elif [[ "$DISTRO" == "24.04" ]]; then
          sudo apt-get -yq install libgtk-3-0 libwebkit2gtk-4.1-dev gcc-aarch64-linux-gnu
        else
          echo "Unsupported Linux distribution: $DISTRO"
          exit 1
        fi
        echo "DISTRO=$DISTRO" >> "$GITHUB_OUTPUT"
    - name: Common metadata (bash)
      if: runner.os != 'Windows'
      id: meta_bash
      shell: bash
      run: |
        set -euo pipefail
        OS="${{ runner.os }}"
        ARCH="$(uname -m)"
        REF="${{ github.ref }}"
        SHA="${{ github.sha }}"
        SHORT_SHA="${SHA::7}"
        REPO="${{ github.repository }}"
        OWNER="${{ github.repository_owner }}"
        TAG=""
        IS_TAG=0
        if [[ "$REF" == refs/tags/* ]]; then
          IS_TAG=1
          TAG="${REF#refs/tags/}"
        fi
        echo "OS=$OS" >> "$GITHUB_OUTPUT"
        echo "ARCH=$ARCH" >> "$GITHUB_OUTPUT"
        echo "REF=$REF" >> "$GITHUB_OUTPUT"
        echo "SHA=$SHA" >> "$GITHUB_OUTPUT"
        echo "SHORT_SHA=$SHORT_SHA" >> "$GITHUB_OUTPUT"
        echo "REPO=$REPO" >> "$GITHUB_OUTPUT"
        echo "OWNER=$OWNER" >> "$GITHUB_OUTPUT"
        echo "TAG=$TAG" >> "$GITHUB_OUTPUT"
        echo "IS_TAG=$IS_TAG" >> "$GITHUB_OUTPUT"
    - name: Common metadata (powershell)
      if: runner.os == 'Windows'
      id: meta_pwsh
      shell: powershell
      run: |
        $OS = "${{ runner.os }}"
        $archEnv = $Env:PROCESSOR_ARCHITECTURE
        if ($archEnv -eq "AMD64") { $ARCH = "amd64" }
        elseif ($archEnv -eq "ARM64") { $ARCH = "arm64" }
        else { $ARCH = $archEnv }
        $REF = "${{ github.ref }}"
        $SHA = "${{ github.sha }}"
        $SHORT_SHA = $SHA.Substring(0,7)
        $REPO = "${{ github.repository }}"
        $OWNER = "${{ github.repository_owner }}"
        $TAG = ""
        $IS_TAG = 0
        if ($REF.StartsWith("refs/tags/")) {
          $IS_TAG = 1
          $TAG = $REF.Substring(10)
        }
        "OS=$OS" >> $Env:GITHUB_OUTPUT
        "ARCH=$ARCH" >> $Env:GITHUB_OUTPUT
        "REF=$REF" >> $Env:GITHUB_OUTPUT
        "SHA=$SHA" >> $Env:GITHUB_OUTPUT
        "SHORT_SHA=$SHORT_SHA" >> $Env:GITHUB_OUTPUT
        "REPO=$REPO" >> $Env:GITHUB_OUTPUT
        "OWNER=$OWNER" >> $Env:GITHUB_OUTPUT
        "TAG=$TAG" >> $Env:GITHUB_OUTPUT
        "IS_TAG=$IS_TAG" >> $Env:GITHUB_OUTPUT
    - name: Project markers (bash)
      if: runner.os != 'Windows'
      id: proj_bash
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: |
        set -euo pipefail
        echo "[DEBUG_LOG] Discovery scanning working dir: $PWD"
        has_root_pkg=0; has_frontend_pkg=0; has_go_mod=0; has_main_go=0; has_cmake=0; has_mkdocs=0
        has_sub_npm=0; has_sub_mkdocs=0
        found_files=()
        # Root markers
        if [ -f "package.json" ]; then has_root_pkg=1; found_files+=("package.json"); fi
        if [ -f "go.mod" ]; then has_go_mod=1; found_files+=("go.mod"); fi
        if [ -f "main.go" ]; then has_main_go=1; found_files+=("main.go"); fi
        if [ -f "CMakeLists.txt" ]; then has_cmake=1; found_files+=("CMakeLists.txt"); fi
        if [ -f "mkdocs.yml" ]; then has_mkdocs=1; found_files+=("mkdocs.yml"); fi
        # Common subtree markers
        if [ -f "frontend/package.json" ]; then has_frontend_pkg=1; found_files+=("frontend/package.json"); fi
        # Light subtree search up to depth 2 for package.json and mkdocs.yml
        if command -v find >/dev/null 2>&1; then
          if find . -maxdepth 2 -mindepth 2 -name package.json | grep -q .; then has_sub_npm=1; fi
          if find . -maxdepth 2 -mindepth 1 -name mkdocs.yml | grep -q .; then has_sub_mkdocs=1; fi
        fi
        # Suggest stack
        suggestion="unknown"
        if { [ "$has_go_mod" -eq 1 ] || [ "$has_main_go" -eq 1 ]; } && { [ "$has_root_pkg" -eq 1 ] || [ "$has_frontend_pkg" -eq 1 ] || [ "$has_sub_npm" -eq 1 ]; }; then
          suggestion="wails2"
        elif [ "$has_cmake" -eq 1 ]; then
          suggestion="cpp"
        fi
        # Output and logs
        echo "[DEBUG_LOG] HAS_ROOT_PACKAGE_JSON=$has_root_pkg"
        echo "[DEBUG_LOG] HAS_FRONTEND_PACKAGE_JSON=$has_frontend_pkg"
        echo "[DEBUG_LOG] HAS_ROOT_GO_MOD=$has_go_mod"
        echo "[DEBUG_LOG] HAS_ROOT_MAIN_GO=$has_main_go"
        echo "[DEBUG_LOG] HAS_ROOT_CMAKELISTS=$has_cmake"
        echo "[DEBUG_LOG] HAS_ROOT_MKDOCS=$has_mkdocs"
        echo "[DEBUG_LOG] HAS_SUB_NPM=$has_sub_npm"
        echo "[DEBUG_LOG] HAS_SUB_MKDOCS=$has_sub_mkdocs"
        echo "[DEBUG_LOG] PRIMARY_STACK_SUGGESTION=$suggestion"
        echo "HAS_ROOT_PACKAGE_JSON=$has_root_pkg" >> "$GITHUB_OUTPUT"
        echo "HAS_FRONTEND_PACKAGE_JSON=$has_frontend_pkg" >> "$GITHUB_OUTPUT"
        echo "HAS_ROOT_GO_MOD=$has_go_mod" >> "$GITHUB_OUTPUT"
        echo "HAS_ROOT_MAIN_GO=$has_main_go" >> "$GITHUB_OUTPUT"
        echo "HAS_ROOT_CMAKELISTS=$has_cmake" >> "$GITHUB_OUTPUT"
        echo "HAS_ROOT_MKDOCS=$has_mkdocs" >> "$GITHUB_OUTPUT"
        echo "HAS_SUB_NPM=$has_sub_npm" >> "$GITHUB_OUTPUT"
        echo "HAS_SUB_MKDOCS=$has_sub_mkdocs" >> "$GITHUB_OUTPUT"
        echo "PRIMARY_STACK_SUGGESTION=$suggestion" >> "$GITHUB_OUTPUT"
        if [ ${#found_files[@]} -gt 0 ]; then
          IFS=,; echo "FOUND_FILES=${found_files[*]}" >> "$GITHUB_OUTPUT"; unset IFS
        else
          echo "FOUND_FILES=" >> "$GITHUB_OUTPUT"
        fi
    - name: Project markers (powershell)
      if: runner.os == 'Windows'
      id: proj_pwsh
      shell: powershell
      working-directory: ${{ inputs.working-directory }}
      run: |
        Write-Host "[DEBUG_LOG] Discovery scanning working dir: $PWD"
        $has_root_pkg=0; $has_frontend_pkg=0; $has_go_mod=0; $has_main_go=0; $has_cmake=0; $has_mkdocs=0
        $has_sub_npm=0; $has_sub_mkdocs=0
        $found = @()
        if (Test-Path package.json) { $has_root_pkg=1; $found+="package.json" }
        if (Test-Path go.mod) { $has_go_mod=1; $found+="go.mod" }
        if (Test-Path main.go) { $has_main_go=1; $found+="main.go" }
        if (Test-Path CMakeLists.txt) { $has_cmake=1; $found+="CMakeLists.txt" }
        if (Test-Path mkdocs.yml) { $has_mkdocs=1; $found+="mkdocs.yml" }
        if (Test-Path frontend/package.json) { $has_frontend_pkg=1; $found+="frontend/package.json" }
        # Limited subtree search (depth ~2)
        Get-ChildItem -Recurse -Depth 2 -Filter package.json -ErrorAction SilentlyContinue | Where-Object { $_.FullName -notlike "*node_modules*" } | ForEach-Object { $has_sub_npm=1 }
        Get-ChildItem -Recurse -Depth 2 -Filter mkdocs.yml -ErrorAction SilentlyContinue | ForEach-Object { $has_sub_mkdocs=1 }
        $suggestion = "unknown"
        if ((($has_go_mod -eq 1) -or ($has_main_go -eq 1)) -and (($has_root_pkg -eq 1) -or ($has_frontend_pkg -eq 1) -or ($has_sub_npm -eq 1))) { $suggestion = "wails2" }
        elseif ($has_cmake -eq 1) { $suggestion = "cpp" }
        Write-Host "[DEBUG_LOG] HAS_ROOT_PACKAGE_JSON=$has_root_pkg"
        Write-Host "[DEBUG_LOG] HAS_FRONTEND_PACKAGE_JSON=$has_frontend_pkg"
        Write-Host "[DEBUG_LOG] HAS_ROOT_GO_MOD=$has_go_mod"
        Write-Host "[DEBUG_LOG] HAS_ROOT_MAIN_GO=$has_main_go"
        Write-Host "[DEBUG_LOG] HAS_ROOT_CMAKELISTS=$has_cmake"
        Write-Host "[DEBUG_LOG] HAS_ROOT_MKDOCS=$has_mkdocs"
        Write-Host "[DEBUG_LOG] HAS_SUB_NPM=$has_sub_npm"
        Write-Host "[DEBUG_LOG] HAS_SUB_MKDOCS=$has_sub_mkdocs"
        Write-Host "[DEBUG_LOG] PRIMARY_STACK_SUGGESTION=$suggestion"
        "HAS_ROOT_PACKAGE_JSON=$has_root_pkg" >> $Env:GITHUB_OUTPUT
        "HAS_FRONTEND_PACKAGE_JSON=$has_frontend_pkg" >> $Env:GITHUB_OUTPUT
        "HAS_ROOT_GO_MOD=$has_go_mod" >> $Env:GITHUB_OUTPUT
        "HAS_ROOT_MAIN_GO=$has_main_go" >> $Env:GITHUB_OUTPUT
        "HAS_ROOT_CMAKELISTS=$has_cmake" >> $Env:GITHUB_OUTPUT
        "HAS_ROOT_MKDOCS=$has_mkdocs" >> $Env:GITHUB_OUTPUT
        "HAS_SUB_NPM=$has_sub_npm" >> $Env:GITHUB_OUTPUT
        "HAS_SUB_MKDOCS=$has_sub_mkdocs" >> $Env:GITHUB_OUTPUT
        "PRIMARY_STACK_SUGGESTION=$suggestion" >> $Env:GITHUB_OUTPUT
        if ($found.Count -gt 0) { "FOUND_FILES=$($found -join ',')" >> $Env:GITHUB_OUTPUT } else { "FOUND_FILES=" >> $Env:GITHUB_OUTPUT }
outputs:
  OS:
    description: "Runner OS (Linux/macOS/Windows)"
    value: ${{ steps.meta_bash.outputs.OS || steps.meta_pwsh.outputs.OS }}
  ARCH:
    description: "CPU architecture (e.g., x86_64/amd64/arm64)"
    value: ${{ steps.meta_bash.outputs.ARCH || steps.meta_pwsh.outputs.ARCH }}
  DISTRO:
    description: "Linux distro version when on Linux (e.g., 20.04/22.04/24.04); empty otherwise"
    value: ${{ steps.linux.outputs.DISTRO }}
  REF:
    description: "The full Git ref"
    value: ${{ steps.meta_bash.outputs.REF || steps.meta_pwsh.outputs.REF }}
  TAG:
    description: "Tag name when running on a tag ref; empty otherwise"
    value: ${{ steps.meta_bash.outputs.TAG || steps.meta_pwsh.outputs.TAG }}
  IS_TAG:
    description: "1 if running on tag ref; 0 otherwise"
    value: ${{ steps.meta_bash.outputs.IS_TAG || steps.meta_pwsh.outputs.IS_TAG }}
  SHA:
    description: "Full commit SHA"
    value: ${{ steps.meta_bash.outputs.SHA || steps.meta_pwsh.outputs.SHA }}
  SHORT_SHA:
    description: "Short commit SHA (7 chars)"
    value: ${{ steps.meta_bash.outputs.SHORT_SHA || steps.meta_pwsh.outputs.SHORT_SHA }}
  REPO:
    description: "owner/repo"
    value: ${{ steps.meta_bash.outputs.REPO || steps.meta_pwsh.outputs.REPO }}
  OWNER:
    description: "Repository owner"
    value: ${{ steps.meta_bash.outputs.OWNER || steps.meta_pwsh.outputs.OWNER }}
  HAS_ROOT_PACKAGE_JSON:
    description: "1 if package.json at root of working-directory"
    value: ${{ steps.proj_bash.outputs.HAS_ROOT_PACKAGE_JSON || steps.proj_pwsh.outputs.HAS_ROOT_PACKAGE_JSON }}
  HAS_FRONTEND_PACKAGE_JSON:
    description: "1 if frontend/package.json under working-directory"
    value: ${{ steps.proj_bash.outputs.HAS_FRONTEND_PACKAGE_JSON || steps.proj_pwsh.outputs.HAS_FRONTEND_PACKAGE_JSON }}
  HAS_ROOT_GO_MOD:
    description: "1 if go.mod at root of working-directory"
    value: ${{ steps.proj_bash.outputs.HAS_ROOT_GO_MOD || steps.proj_pwsh.outputs.HAS_ROOT_GO_MOD }}
  HAS_ROOT_MAIN_GO:
    description: "1 if main.go at root of working-directory"
    value: ${{ steps.proj_bash.outputs.HAS_ROOT_MAIN_GO || steps.proj_pwsh.outputs.HAS_ROOT_MAIN_GO }}
  HAS_ROOT_CMAKELISTS:
    description: "1 if CMakeLists.txt at root of working-directory"
    value: ${{ steps.proj_bash.outputs.HAS_ROOT_CMAKELISTS || steps.proj_pwsh.outputs.HAS_ROOT_CMAKELISTS }}
  HAS_ROOT_MKDOCS:
    description: "1 if mkdocs.yml at root of working-directory"
    value: ${{ steps.proj_bash.outputs.HAS_ROOT_MKDOCS || steps.proj_pwsh.outputs.HAS_ROOT_MKDOCS }}
  HAS_SUB_NPM:
    description: "1 if a nested package.json was found within depth 2"
    value: ${{ steps.proj_bash.outputs.HAS_SUB_NPM || steps.proj_pwsh.outputs.HAS_SUB_NPM }}
  HAS_SUB_MKDOCS:
    description: "1 if a nested mkdocs.yml was found within depth 2"
    value: ${{ steps.proj_bash.outputs.HAS_SUB_MKDOCS || steps.proj_pwsh.outputs.HAS_SUB_MKDOCS }}
  PRIMARY_STACK_SUGGESTION:
    description: "Computed primary stack suggestion (wails2/cpp/unknown)"
    value: ${{ steps.proj_bash.outputs.PRIMARY_STACK_SUGGESTION || steps.proj_pwsh.outputs.PRIMARY_STACK_SUGGESTION }}
  FOUND_FILES:
    description: "Comma-separated summary of notable files found"
    value: ${{ steps.proj_bash.outputs.FOUND_FILES || steps.proj_pwsh.outputs.FOUND_FILES }}
